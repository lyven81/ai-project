# -*- coding: utf-8 -*-
"""Customer Segmentation and Market Agent

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1PiZk0nmzKrAxvKdCEKNoeMOMETdrzr-4
"""

# Install required packages
!pip install -q tinydb google-generativeai pandas matplotlib seaborn

# ==== Imports ====
from __future__ import annotations
import json
import pandas as pd
import re
import io
import sys
import traceback
from typing import Any, Dict, Optional
from tinydb import TinyDB, Query
from tinydb.storages import MemoryStorage
from datetime import datetime, timedelta
from collections import defaultdict, Counter
from IPython.display import HTML, display
import google.generativeai as genai

# Visualization
import matplotlib.pyplot as plt
import seaborn as sns
sns.set_style("whitegrid")
plt.rcParams['figure.figsize'] = (10, 6)

print("âœ… All libraries imported successfully!")

# Use Colab Secrets (RECOMMENDED)
from google.colab import userdata
GEMINI_API_KEY = userdata.get('GEMINI_API_KEY')

# Configure Gemini
genai.configure(api_key=GEMINI_API_KEY)

print("âœ… Gemini API configured!")

def print_html(content: str, title: str = ""):
    """Display formatted HTML output."""
    html = f"""
    <div style="border:1px solid #3B82F6; border-left:6px solid #3B82F6;
                background:#EFF6FF; border-radius:8px; padding:16px;
                margin:10px 0; font-family:monospace;">
        <h4 style="margin-top:0; color:#1E40AF;">{title}</h4>
        <pre style="white-space: pre-wrap; word-wrap: break-word;">{content}</pre>
    </div>
    """
    display(HTML(html))

print("âœ… Utility functions loaded!")

# Upload CSV file
from google.colab import files

print("ðŸ“ Please upload your dataset.csv file:")
uploaded = files.upload()
csv_filename = list(uploaded.keys())[0]
print(f"âœ… File uploaded: {csv_filename}")

# Load and prepare data
df = pd.read_csv(csv_filename)
df.columns = df.columns.str.strip()

# Convert data types
df['Order_Date'] = pd.to_datetime(df['Order_Date'], format='%m-%d-%y', errors='coerce')
df['Unit_Price'] = pd.to_numeric(df['Unit_Price'], errors='coerce')
df['Revenue'] = pd.to_numeric(df['Revenue'], errors='coerce')
df['Profit'] = pd.to_numeric(df['Profit'], errors='coerce')
df['Quantity'] = pd.to_numeric(df['Quantity'], errors='coerce')

print(f"ðŸ“Š Dataset loaded: {len(df)} orders")
print(f"ðŸ‘¥ Unique customers: {df['Customer_Name'].nunique()}")
df.head()

def create_marketing_database(df: pd.DataFrame) -> tuple:
    """
    Create TinyDB with 3 tables:
    - orders_tbl: Historical order data (READ-ONLY)
    - customers_tbl: Customer profiles (READ/WRITE) - starts EMPTY
    - campaigns_tbl: Marketing campaigns (READ/WRITE) - starts EMPTY
    """
    db = TinyDB(storage=MemoryStorage)

    # Table 1: Orders (from CSV)
    orders_tbl = db.table('orders')
    df_copy = df.copy()
    df_copy['Order_Date'] = df_copy['Order_Date'].dt.strftime('%Y-%m-%d')
    records = df_copy.to_dict('records')
    orders_tbl.insert_multiple(records)

    # Table 2: Customers (empty - agent will populate)
    customers_tbl = db.table('customers')

    # Table 3: Campaigns (empty - agent will create)
    campaigns_tbl = db.table('campaigns')

    return db, orders_tbl, customers_tbl, campaigns_tbl

# Create database
db, orders_tbl, customers_tbl, campaigns_tbl = create_marketing_database(df)

print(f"âœ… Database created!")
print(f"   ðŸ“¦ Orders: {len(orders_tbl)}")
print(f"   ðŸ‘¥ Customers: {len(customers_tbl)} (empty)")
print(f"   ðŸ“¢ Campaigns: {len(campaigns_tbl)} (empty)")

# Preview tables
print_html(json.dumps(orders_tbl.all()[:2], indent=2), "Orders Table Sample")

def get_next_customer_id(customers_tbl) -> int:
    """Generate next customer ID (auto-increment)."""
    all_customers = customers_tbl.all()
    if not all_customers:
        return 1
    return max(c.get('customer_id', 0) for c in all_customers) + 1

def get_next_campaign_id(campaigns_tbl) -> str:
    """Generate next campaign ID (CAMP001, CAMP002, etc.)."""
    all_campaigns = campaigns_tbl.all()
    if not all_campaigns:
        return "CAMP001"
    numbers = []
    for c in all_campaigns:
        cid = c.get('campaign_id', 'CAMP000')
        num = int(re.search(r'\d+', cid).group()) if re.search(r'\d+', cid) else 0
        numbers.append(num)
    next_num = max(numbers) + 1 if numbers else 1
    return f"CAMP{next_num:03d}"

def calculate_days_since(date_str: str) -> int:
    """Calculate days between a date string and today."""
    try:
        past_date = datetime.strptime(date_str, '%Y-%m-%d')
        return (datetime.now() - past_date).days
    except:
        return 0

print("âœ… Helper functions loaded!")

def build_schema_block(orders_tbl, customers_tbl, campaigns_tbl) -> str:
    """
    Generate schema description with samples.
    """
    orders_sample = orders_tbl.all()[:1]
    customers_sample = customers_tbl.all()[:1] if customers_tbl.all() else []
    campaigns_sample = campaigns_tbl.all()[:1] if campaigns_tbl.all() else []

    schema = f"""
=== TABLE 1: ORDERS (orders_tbl) === [READ-ONLY]
Total Records: {len(orders_tbl)}

Schema:
- Order_ID (int): Unique order identifier
- Order_Date (string): Date in YYYY-MM-DD format
- Customer_Name (string): Customer name
- City, State, Region, Country (string): Geographic info
- Category (string): Product category (Electronics, Clothing, etc.)
- Sub_Category (string): Detailed category
- Product_Name (string): Specific product
- Quantity (int): Units ordered
- Unit_Price (float): Price per unit (USD)
- Revenue (float): Total revenue
- Profit (float): Profit from order

Sample: {json.dumps(orders_sample, indent=2)}

=== TABLE 2: CUSTOMERS (customers_tbl) === [READ/WRITE]
Total Records: {len(customers_tbl)}

Schema:
- customer_id (int): Unique ID (use get_next_customer_id())
- customer_name (string): Name (matches Order.Customer_Name)
- total_orders (int): Number of orders
- total_spent (float): Total revenue generated
- total_profit_contributed (float): Total profit
- average_order_value (float): total_spent / total_orders
- first_order_date (string): Date of first order
- last_order_date (string): Date of most recent order
- days_since_last_order (int): Days since last purchase
- favorite_category (string): Most purchased category
- segment (string): VIP/Regular/At-Risk/New/Churned
- tags (list): Custom tags
- created_date (string): When record was created
- last_updated (string): When record was last modified

Sample: {json.dumps(customers_sample, indent=2) if customers_sample else 'Empty'}

=== TABLE 3: CAMPAIGNS (campaigns_tbl) === [READ/WRITE]
Total Records: {len(campaigns_tbl)}

Schema:
- campaign_id (string): Unique ID (use get_next_campaign_id())
- campaign_name (string): Campaign name
- target_segment (string): Target segment
- target_customer_count (int): Number of customers
- target_customer_ids (list): IDs of matching customers
- status (string): draft/active/completed
- created_date (string): When created

Sample: {json.dumps(campaigns_sample, indent=2) if campaigns_sample else 'Empty'}
"""
    return schema

schema_block = build_schema_block(orders_tbl, customers_tbl, campaigns_tbl)
print_html(schema_block, "Database Schema (3 Tables)")

MARKETING_AGENT_PROMPT = """You are a senior customer intelligence analyst. PLAN BY WRITING PYTHON CODE USING TINYDB.

Database Schema & Samples:
{schema_block}

Execution Environment (already imported/provided):
- Variables: db, orders_tbl, customers_tbl, campaigns_tbl  # TinyDB objects
- Helpers:
  * get_next_customer_id(customers_tbl) -> int
  * get_next_campaign_id(campaigns_tbl) -> str
  * calculate_days_since(date_str) -> int
- Libraries: Query, datetime, Counter, defaultdict, plt, sns
- Natural language: user_request: str

PLANNING RULES (critical):
- Derive ALL filters/parameters from user_request
- Build TinyDB queries dynamically with Query()
- For dates: use string comparison (YYYY-MM-DD)
- Be conservative: if intent is ambiguous, do read-only

CUSTOMER PROFILE RULES:
When creating customer profiles:
1. Use get_next_customer_id(customers_tbl) for new customer_id
2. Calculate ALL metrics from orders_tbl
3. Assign segment based on:
   - VIP: total_spent > $2000 AND total_orders >= 5
   - Regular: total_spent $500-$2000
   - At-Risk: days_since_last_order > 180
   - New: total_orders <= 2
   - Churned: days_since_last_order > 365
4. Set created_date and last_updated timestamps

CAMPAIGN RULES:
When creating campaigns:
1. Use get_next_campaign_id(campaigns_tbl)
2. Count matching customers
3. Store customer_ids in target_customer_ids
4. Set status to "draft"

VISUALIZATION SUPPORT:
If user requests charts/graphs:
1. Generate matplotlib/seaborn code
2. Use plt.figure(figsize=(10, 6))
3. Add titles, labels, legends
4. Call plt.tight_layout() and plt.show()

HUMAN RESPONSE REQUIREMENT (hard):
- You MUST set `answer_text` (str) with concise answer (2-3 sentences)
- Include relevant numbers and insights
- If visualization created, mention it
- Format currency as "$X,XXX.XX"

OUTPUT CONTRACT:
Return ONLY executable Python between these tags:
<execute_python>
# your code here
</execute_python>

CODE CHECKLIST:
1) Parse user_request
2) Build TinyDB queries
3) Perform calculations/mutations
4) If visualization requested: generate chart
5) ALWAYS set answer_text
6) Print brief debug log

EXAMPLE: Create customer profile
Item = Query()
customer_name = "John Doe"
orders = orders_tbl.search(Item.Customer_Name == customer_name)
total_spent = sum(o['Revenue'] for o in orders)
customers_tbl.insert({{
    'customer_id': get_next_customer_id(customers_tbl),
    'customer_name': customer_name,
    'total_spent': total_spent,
    'segment': 'VIP' if total_spent > 2000 else 'Regular',
    'created_date': datetime.now().strftime('%Y-%m-%d')
}})
answer_text = f"Created profile for {{customer_name}}: ${{total_spent:,.2f}} spent."

User request:
{question}
"""

print("âœ… Marketing Agent prompt loaded!")

def generate_llm_code(
    prompt: str,
    *,
    orders_tbl,
    customers_tbl,
    campaigns_tbl,
    model: str = "gemini-2.0-flash-exp",
    temperature: float = 0.3,
) -> str:
    """
    Ask Gemini to produce a plan-with-code response.
    Returns the FULL response (including <execute_python> tags).
    """
    schema_block = build_schema_block(orders_tbl, customers_tbl, campaigns_tbl)
    full_prompt = MARKETING_AGENT_PROMPT.format(schema_block=schema_block, question=prompt)

    generation_config = {
        "temperature": temperature,
        "top_p": 0.95,
        "top_k": 40,
        "max_output_tokens": 8192,
    }

    model_instance = genai.GenerativeModel(
        model_name=model,
        generation_config=generation_config,
    )

    response = model_instance.generate_content(full_prompt)
    return response.text

print("âœ… Code generation function loaded!")

def _extract_execute_block(text: str) -> str:
    """
    Extract Python code from <execute_python>...</execute_python> tags.
    If no tags, assume text is raw code.
    """
    if not text:
        raise RuntimeError("Empty content passed to code executor.")
    m = re.search(r"<execute_python>(.*?)</execute_python>", text, re.DOTALL | re.IGNORECASE)
    code = m.group(1).strip() if m else text.strip()

    # Remove markdown code blocks
    code = re.sub(r"```python\n?", "", code, count=1)
    code = re.sub(r"```\n?", "", code)

    return code.strip()


def execute_generated_code(
    code_or_content: str,
    *,
    db,
    orders_tbl,
    customers_tbl,
    campaigns_tbl,
    user_request: Optional[str] = None,
) -> Dict[str, Any]:
    """
    Execute code in a controlled namespace.
    Following template pattern: safe globals + locals.
    """
    code = _extract_execute_block(code_or_content)

    # SAFE_GLOBALS: Functions and libraries
    SAFE_GLOBALS = {
        "Query": Query,
        "datetime": datetime,
        "timedelta": timedelta,
        "Counter": Counter,
        "defaultdict": defaultdict,
        "user_request": user_request or "",
        "re": re,
        "sum": sum,
        "len": len,
        "max": max,
        "min": min,
        "sorted": sorted,
        "get_next_customer_id": get_next_customer_id,
        "get_next_campaign_id": get_next_campaign_id,
        "calculate_days_since": calculate_days_since,
        "plt": plt,
        "sns": sns,
    }

    # SAFE_LOCALS: Database tables
    SAFE_LOCALS = {
        "db": db,
        "orders_tbl": orders_tbl,
        "customers_tbl": customers_tbl,
        "campaigns_tbl": campaigns_tbl,
    }

    # Capture stdout
    _stdout_buf, _old_stdout = io.StringIO(), sys.stdout
    sys.stdout = _stdout_buf
    err_text = None

    try:
        exec(code, SAFE_GLOBALS, SAFE_LOCALS)
    except Exception:
        err_text = traceback.format_exc()
    finally:
        sys.stdout = _old_stdout

    printed = _stdout_buf.getvalue().strip()

    # Extract answer
    answer = (
        SAFE_LOCALS.get("answer_text")
        or SAFE_LOCALS.get("answer_rows")
        or SAFE_LOCALS.get("answer_json")
        or "No answer generated"
    )

    return {
        "code": code,
        "stdout": printed,
        "error": err_text,
        "answer": answer,
    }

print("âœ… Code execution function loaded!")

def marketing_agent(
    question: str,
    *,
    db,
    orders_tbl,
    customers_tbl,
    campaigns_tbl,
    model: str = "gemini-2.0-flash-exp",
    temperature: float = 0.3,
) -> dict:
    """
    End-to-end marketing agent:
    1) Show question
    2) Generate plan-as-code
    3) Show before snapshots
    4) Execute
    5) Show answer and after snapshots
    """
    # 1) Show question
    print_html(question, "User Question")

    # 2) Generate plan
    full_content = generate_llm_code(
        question,
        orders_tbl=orders_tbl,
        customers_tbl=customers_tbl,
        campaigns_tbl=campaigns_tbl,
        model=model,
        temperature=temperature,
    )
    print_html(full_content, "Plan with Code (Full Response)")

    # 3) Before snapshots
    print_html(json.dumps(customers_tbl.all()[:3], indent=2), "Customers Table Â· Before")
    print_html(json.dumps(campaigns_tbl.all()[:3], indent=2), "Campaigns Table Â· Before")

    # 4) Execute
    exec_res = execute_generated_code(
        full_content,
        db=db,
        orders_tbl=orders_tbl,
        customers_tbl=customers_tbl,
        campaigns_tbl=campaigns_tbl,
        user_request=question,
    )

    # 5) Show results
    if exec_res["error"]:
        print_html(exec_res["error"], "âŒ Execution Error")
    else:
        print_html(exec_res["answer"], "Plan Execution Â· Extracted Answer")
        if exec_res["stdout"]:
            print_html(exec_res["stdout"], "Debug Logs")

    # After snapshots
    print_html(json.dumps(customers_tbl.all()[:3], indent=2), "Customers Table Â· After")
    print_html(json.dumps(campaigns_tbl.all()[:3], indent=2), "Campaigns Table Â· After")

    return {
        "full_content": full_content,
        "exec": exec_res,
    }

print("âœ… Marketing Agent ready!")

# Get 1000 random customers
  sample_customers = df['Customer_Name'].drop_duplicates().sample(n=1000, random_state=42)

  # Filter orders for those customers
  df_sample = df[df['Customer_Name'].isin(sample_customers)]

  print(f"ðŸ“Š Sample: {len(df_sample)} orders, {df_sample['Customer_Name'].nunique()} customers")

# View the generated code to see what went wrong
print("=" * 50)
print("GENERATED CODE:")
print("=" * 50)
print(result['exec']['code'])
print("=" * 50)

def _extract_execute_block(text: str) -> str:
      """
      Extract Python code from <execute_python>...</execute_python> tags.
      FIXED: Properly handle closing tags
      """
      if not text:
          raise RuntimeError("Empty content passed to code executor.")

      # Search for <execute_python>...</execute_python> block
      m = re.search(r"<execute_python>(.*?)</execute_python>", text, re.DOTALL | re.IGNORECASE)
      code = m.group(1).strip() if m else text.strip()

      # Remove markdown code blocks
      code = re.sub(r"```python\n?", "", code)
      code = re.sub(r"```\n?$", "", code)

      # Remove any stray closing tags
      code = re.sub(r"</execute_python>.*$", "", code, flags=re.DOTALL)

      return code.strip()

  print("âœ… Fixed extraction function!")

result = marketing_agent(
    "Who are our top 10 VIP customers by total spending? can you present in bar chart and label it?",
    db=db,
    orders_tbl=orders_tbl,
    customers_tbl=customers_tbl,
    campaigns_tbl=campaigns_tbl,
)

result = marketing_agent(
    "How many customers are in each segment (VIP, Regular, At-Risk, New, Churned)?",
    db=db,
    orders_tbl=orders_tbl,
    customers_tbl=customers_tbl,
    campaigns_tbl=campaigns_tbl,
)

result = marketing_agent(
    "Create a holiday campaign targeting VIP customers who spent over $2000. Name it 'VIP Holiday Sale 2024'.",
    db=db,
    orders_tbl=orders_tbl,
    customers_tbl=customers_tbl,
    campaigns_tbl=campaigns_tbl,
)

result = marketing_agent(
    "What is the average order value of at-risk segment customers?",
    db=db,
    orders_tbl=orders_tbl,
    customers_tbl=customers_tbl,
    campaigns_tbl=campaigns_tbl,
)

result = marketing_agent(
    "Create a holiday campaign targeting at-risk customers who spent below $600. Name it 'Super Saving'.",
    db=db,
    orders_tbl=orders_tbl,
    customers_tbl=customers_tbl,
    campaigns_tbl=campaigns_tbl,
)

result = marketing_agent(
    "Which product category has the highest number of customer who spend below $1000?",
    db=db,
    orders_tbl=orders_tbl,
    customers_tbl=customers_tbl,
    campaigns_tbl=campaigns_tbl,
)

result = marketing_agent(
    "How many customers are in each segment?",
    db=db,
    orders_tbl=orders_tbl,
    customers_tbl=customers_tbl,
    campaigns_tbl=campaigns_tbl,
)



result = marketing_agent(
    "Who are our top 10 customers by profit?",
    db=db,
    orders_tbl=orders_tbl,
    customers_tbl=customers_tbl,
    campaigns_tbl=campaigns_tbl,
)

result = marketing_agent(
    "Create a campaign targeting At-Risk customers in the East region. Name it 'Look East Campaign",
    db=db,
    orders_tbl=orders_tbl,
    customers_tbl=customers_tbl,
    campaigns_tbl=campaigns_tbl,
)