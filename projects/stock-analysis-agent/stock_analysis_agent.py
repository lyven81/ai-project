# -*- coding: utf-8 -*-
"""Stock-analysis-agent

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Wji69Sq-IqhtMEJTlxIkQ39ZZ5JAXR6w

# Stock Review Workflow - Multi-Agent Investment Analysis

## 1. Introduction

### 1.1. Lab Overview

In this lab, you will step into the role of a **retail investor** analyzing Malaysian stocks for long-term dividend-focused investments. Your task is to design a **fully automated investment analysis pipeline** that mirrors real-world stock screening and fundamental analysis.

Instead of manually reviewing financial statements and calculating ratios, you will guide a team of specialized AI agents that:
- Screen stocks based on your investment criteria (Price, PE, ROE, Dividend Yield, etc.)
- Analyze fundamental metrics (profitability, financial health, valuation)
- Research business moats and competitive advantages
- Evaluate dividend sustainability and cash flow
- Generate executive-ready investment reports with buy/hold/avoid recommendations

The goal is to experience how multiple agents, tools, and real market data can be orchestrated into a single, coherent investment analysis workflow.

### 1.2. üéØ Learning Outcomes

By completing this lab, you will learn how to:
- Build **multi-agent investment analysis pipelines** that coordinate data gathering, analysis, and reporting
- Ground agent reasoning in **real financial data** from Yahoo Finance and web sources
- Implement **structured investment frameworks** (7-category yardstick scoring)
- Combine **quantitative metrics** (PE, ROE, DY) with **qualitative research** (moat, management)
- Generate **actionable investment reports** ready for decision-making

### 1.3. üìã Investment Criteria

Your screening criteria (based on RM35 budget for 100 units):

| Metric | Range | Why It Matters |
|--------|-------|----------------|
| **Price** | ‚â§ RM 0.26 | Affordable within budget |
| **PE Ratio** | 4 - 15 | Fair valuation, avoids loss-making firms |
| **ROE** | ‚â• 5% | Profitability indicator |
| **EPS** | ‚â• 0.01 | Actual profit generation |
| **Dividend Yield** | ‚â• 1% | Passive income potential |
| **Market Cap** | ‚â• RM 50M | Filters out very small, risky companies |
| **Volume** | ‚â• 50,000 shares/day | Liquidity for easy buy/sell |

**Optional Quality Filters:**
- NTA (Net Tangible Assets) ‚â• RM 0.20
- PTBV (Price-to-Book) ‚â§ 1.5
- PSR (Price-to-Sales) ‚â§ 2.0

### 1.4. üèÜ Investment Yardstick (7 Categories)

After screening, stocks are evaluated against a comprehensive scoring system:

1. **Fundamentals & Profitability** (20%) - ROE, EPS, margins
2. **Financial Health & Solvency** (15%) - Debt ratios, NTA, current ratio
3. **Valuation** (20%) - PE, PTBV, PSR
4. **Business Moat** (15%) - Competitive advantages, brand strength
5. **Cash Flow & Dividends** (15%) - DY, payout ratio, FCF trends
6. **Management & Outlook** (10%) - Track record, governance
7. **Liquidity** (5%) - Trading volume, bid-ask spread

**Total Score:** 0-100
- **80-100:** Strong Buy üü¢
- **60-79:** Buy üü°
- **40-59:** Hold ‚ö™
- **0-39:** Avoid üî¥

## 2. Setup: Install Libraries and Configure Environment
"""

# Install required packages for Google Colab
!pip install -q google-generativeai yfinance pandas matplotlib seaborn tavily-python

# =========================
# Imports
# =========================

import json
import os
import re
from datetime import datetime, timedelta
from typing import Dict, List, Any

import yfinance as yf
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns
import google.generativeai as genai
from tavily import TavilyClient
from IPython.display import Markdown, display, HTML

sns.set_style("whitegrid")
plt.rcParams['figure.figsize'] = (10, 6)
plt.rcParams['font.size'] = 10

# =========================
# API Configuration
# =========================

try:
    from google.colab import userdata
    GOOGLE_API_KEY = userdata.get('GOOGLE_API_KEY')
    TAVILY_API_KEY = userdata.get('TAVILY_API_KEY')
except:
    GOOGLE_API_KEY = ""  # Paste your Google AI Studio API key here
    TAVILY_API_KEY = ""  # Paste your Tavily API key here

genai.configure(api_key=GOOGLE_API_KEY)
tavily_client = TavilyClient(api_key=TAVILY_API_KEY)
model = genai.GenerativeModel('gemini-2.0-flash-exp')

print("‚úÖ APIs configured successfully")

"""## 3. Utility Functions"""

# =========================
# Utility Functions for Logging
# =========================

def log_agent_title_html(title: str, emoji: str):
    html = f"""
    <div style="border:2px solid #3b82f6; border-left:8px solid #2563eb; background:#dbeafe;
                border-radius:8px; padding:16px; margin:16px 0; color:#1e3a8a;">
        <h3 style="margin:0;">{emoji} {title}</h3>
    </div>
    """
    display(HTML(html))

def log_tool_call_html(tool_name: str, args: str = ""):
    html = f"""
    <div style="border:1px solid #a855f7; border-left:4px solid #9333ea; background:#f3e8ff;
                border-radius:6px; padding:12px; margin:8px 0; color:#581c87;">
        <strong>üîß Tool Call:</strong> <code>{tool_name}</code>
        {f'<br><small>Args: {args[:100]}...</small>' if args else ''}
    </div>
    """
    display(HTML(html))

def log_tool_result_html(result: str):
    result_preview = str(result)[:300] + "..." if len(str(result)) > 300 else str(result)
    html = f"""
    <div style="border:1px solid #10b981; border-left:4px solid #059669; background:#d1fae5;
                border-radius:6px; padding:12px; margin:8px 0; color:#065f46;">
        <strong>‚úÖ Result:</strong> <code>{result_preview}</code>
    </div>
    """
    display(HTML(html))

def log_final_summary_html(summary: str):
    html = f"""
    <div style="border:2px solid #f59e0b; border-left:8px solid #d97706; background:#fef3c7;
                border-radius:8px; padding:16px; margin:16px 0; color:#78350f;">
        <strong>üìã Agent Summary:</strong><br>
        <div style="margin-top:8px; white-space:pre-wrap;">{summary}</div>
    </div>
    """
    display(HTML(html))

print("‚úÖ Utility functions loaded")

"""## 4. Tool Definitions - Real Data Sources

### 4.1. Stock Data Tool (yfinance)

This tool fetches real financial data from Yahoo Finance for Malaysian stocks (`.KL` suffix).
"""

# =========================
# Tool: Get Stock Financial Data
# =========================

def get_stock_data(ticker: str) -> dict:
    """
    Fetch comprehensive stock data from Yahoo Finance.

    Args:
        ticker (str): Stock ticker (e.g., '1818.KL' for Bursa Malaysia)

    Returns:
        dict: Financial metrics including price, PE, ROE, dividend yield, etc.
    """
    try:
        stock = yf.Ticker(ticker)
        info = stock.info

        # Get historical data for volume calculation
        hist = stock.history(period='1mo')
        avg_volume = hist['Volume'].mean() if not hist.empty else 0

        # Extract key metrics
        data = {
            'ticker': ticker,
            'name': info.get('longName', 'N/A'),
            'price': info.get('currentPrice', info.get('regularMarketPrice', 0)),
            'currency': info.get('currency', 'MYR'),

            # Valuation metrics
            'pe_ratio': info.get('trailingPE', info.get('forwardPE', None)),
            'price_to_book': info.get('priceToBook', None),
            'price_to_sales': info.get('priceToSalesTrailing12Months', None),

            # Profitability
            'roe': info.get('returnOnEquity', None),
            'eps': info.get('trailingEps', None),
            'profit_margin': info.get('profitMargins', None),
            'operating_margin': info.get('operatingMargins', None),

            # Financial health
            'debt_to_equity': info.get('debtToEquity', None),
            'current_ratio': info.get('currentRatio', None),
            'book_value': info.get('bookValue', None),

            # Dividends
            'dividend_yield': info.get('dividendYield', None),
            'payout_ratio': info.get('payoutRatio', None),
            'dividend_rate': info.get('dividendRate', None),

            # Market data
            'market_cap': info.get('marketCap', None),
            'avg_volume': int(avg_volume),
            'volume': info.get('volume', None),

            # Business info
            'sector': info.get('sector', 'N/A'),
            'industry': info.get('industry', 'N/A'),
            'summary': info.get('longBusinessSummary', 'N/A')
        }

        # Convert percentages to readable format
        if data['roe']:
            data['roe_pct'] = data['roe'] * 100
        if data['dividend_yield']:
            data['dividend_yield_pct'] = data['dividend_yield'] * 100

        return data

    except Exception as e:
        return {'error': str(e), 'ticker': ticker}

print("‚úÖ Stock data tool loaded")

"""### 4.2. Web Search Tool (Tavily)

This tool performs web searches to research business moats, competitive advantages, and company news.
"""

# =========================
# Tool: Web Search for Qualitative Research
# =========================

def search_company_info(query: str, max_results: int = 5) -> list:
    """
    Search for company information, news, and analysis.

    Args:
        query (str): Search query (e.g., "Bursa Malaysia business moat competitive advantage")
        max_results (int): Maximum number of results

    Returns:
        list: Search results with titles, content, URLs
    """
    try:
        response = tavily_client.search(
            query=query,
            max_results=max_results,
            search_depth="advanced"
        )

        results = []
        for item in response.get('results', []):
            results.append({
                'title': item.get('title', ''),
                'content': item.get('content', ''),
                'url': item.get('url', '')
            })

        return results
    except Exception as e:
        return [{'error': str(e)}]

print("‚úÖ Web search tool loaded")

def get_malaysian_stock_list(use_klci_components: bool = True) -> list:
    """
    Get list of Malaysian stocks to screen.

    Args:
        use_klci_components (bool): If True, get major Malaysian stocks

    Returns:
        list: Stock tickers with .KL suffix
    """
    if use_klci_components:
        try:
            # Curated list of major Malaysian stocks
            # Includes KLCI components and other liquid stocks
            major_stocks = [
                # Banking & Financial Services
                '1155.KL',  # Malayan Banking (Maybank)
                '1295.KL',  # Public Bank
                '5819.KL',  # Hong Leong Bank
                '1066.KL',  # RHB Bank
                '1023.KL',  # CIMB Group
                '6947.KL',  # Affin Bank
                '5347.KL',  # AMMB Holdings

                # Telecommunications
                '6888.KL',  # Axiata Group
                '4863.KL',  # Telekom Malaysia
                '4197.KL',  # DIGI.COM
                '6033.KL',  # Maxis

                # Plantation & Agriculture
                '5296.KL',  # Sime Darby Plantation
                '2445.KL',  # IOI Corporation
                '5285.KL',  # Kuala Lumpur Kepong
                '1961.KL',  # FGV Holdings
                '8869.KL',  # TSH Resources

                # Oil & Gas
                '5222.KL',  # Petronas Gas
                '3816.KL',  # MISC
                '1210.KL',  # Dialog Group

                # Construction & Property
                '1082.KL',  # Gamuda
                '4065.KL',  # IJM Corporation
                '5878.KL',  # WCT Holdings
                '6998.KL',  # UEM Sunrise

                # Consumer Products
                '3689.KL',  # Nestle Malaysia
                '5225.KL',  # British American Tobacco
                '4707.KL',  # Fraser & Neave
                '7277.KL',  # Dutch Lady Milk

                # Healthcare
                '4324.KL',  # Pharmaniaga

                # Technology & Services
                '0045.KL',  # Silverlake Axis
                '0186.KL',  # Revenue Group

                # Industrial
                '4502.KL',  # Press Metal
                '5681.KL',  # YTL Corporation
                '2887.KL',  # YTL Power

                # Transport & Logistics
                '5032.KL',  # AIRASIA Group
                '5238.KL',  # Malaysia Airports

                # Bursa & Finance
                '1818.KL',  # Bursa Malaysia
            ]

            # Remove duplicates
            major_stocks = list(set(major_stocks))

            return major_stocks

        except Exception as e:
            print(f"Error fetching stock list: {e}")
            print("Using fallback list...")

    # Fallback: Predefined list of liquid Malaysian stocks
    fallback_stocks = [
        '1155.KL', '1295.KL', '5819.KL', '1066.KL', '1023.KL',
        '6888.KL', '4863.KL', '4197.KL', '6033.KL',
        '5296.KL', '2445.KL', '5285.KL',
        '5222.KL', '3816.KL',
        '1082.KL', '4065.KL',
        '3689.KL', '5225.KL',
        '1818.KL'
    ]

    return fallback_stocks

def batch_screen_stocks(
    ticker_list: list,
    criteria: dict = None,
    max_stocks_to_screen: int = 50,
    verbose: bool = True
) -> pd.DataFrame:
    """
    Screen multiple stocks and return results in a DataFrame.

    Args:
        ticker_list (list): List of stock tickers to screen
        criteria (dict): Screening criteria
        max_stocks_to_screen (int): Maximum number of stocks to process
        verbose (bool): Print progress

    Returns:
        pd.DataFrame: Screening results with pass/fail status
    """
    print(f"\nüîç Batch Screening {len(ticker_list[:max_stocks_to_screen])} stocks...")
    print("="*70 + "\n")

    results = []
    passed_count = 0
    failed_count = 0
    error_count = 0

    for i, ticker in enumerate(ticker_list[:max_stocks_to_screen], 1):
        if verbose:
            print(f"[{i}/{min(len(ticker_list), max_stocks_to_screen)}] Screening {ticker}...", end=" ")

        try:
            # Get stock data without running full screening agent
            stock_data = get_stock_data(ticker)

            if 'error' in stock_data:
                if verbose:
                    print(f"‚ùå Error")
                error_count += 1
                continue

            # Default criteria
            if criteria is None:
                criteria = {
                    'max_price': 0.26,  # RM35 budget / 100 units = RM0.35, use 0.26 for safety margin
                    'min_pe': 4,
                    'max_pe': 15,
                    'min_roe': 5,
                    'min_eps': 0.01,
                    'min_dividend_yield': 1,
                    'min_market_cap': 50_000_000,
                    'min_volume': 50_000
                }

            # Check criteria
            passed = True
            checks = {
                'price': stock_data.get('price', float('inf')),
                'pe_ratio': stock_data.get('pe_ratio'),
                'roe_pct': stock_data.get('roe_pct'),
                'eps': stock_data.get('eps'),
                'dividend_yield_pct': stock_data.get('dividend_yield_pct'),
                'market_cap': stock_data.get('market_cap', 0),
                'avg_volume': stock_data.get('avg_volume', 0)
            }

            # Evaluate each criterion
            if checks['price'] > criteria['max_price']:
                passed = False
            if checks['pe_ratio'] is None or checks['pe_ratio'] < criteria['min_pe'] or checks['pe_ratio'] > criteria['max_pe']:
                passed = False
            if checks['roe_pct'] is None or checks['roe_pct'] < criteria['min_roe']:
                passed = False
            if checks['eps'] is None or checks['eps'] < criteria['min_eps']:
                passed = False
            if checks['dividend_yield_pct'] is None or checks['dividend_yield_pct'] < criteria['min_dividend_yield']:
                passed = False
            if checks['market_cap'] < criteria['min_market_cap']:
                passed = False
            if checks['avg_volume'] < criteria['min_volume']:
                passed = False

            # Store results
            results.append({
                'ticker': ticker,
                'name': stock_data.get('name', 'N/A'),
                'price': checks['price'],
                'pe_ratio': checks['pe_ratio'],
                'roe_pct': checks['roe_pct'],
                'eps': checks['eps'],
                'dividend_yield_pct': checks['dividend_yield_pct'],
                'market_cap': checks['market_cap'],
                'avg_volume': checks['avg_volume'],
                'sector': stock_data.get('sector', 'N/A'),
                'passed': passed
            })

            if passed:
                if verbose:
                    print("‚úÖ PASSED")
                passed_count += 1
            else:
                if verbose:
                    print("‚ùå Failed")
                failed_count += 1

        except Exception as e:
            if verbose:
                print(f"‚ùå Error: {str(e)}")
            error_count += 1
            continue

    df = pd.DataFrame(results)

    print("\n" + "="*70)
    print("üìä BATCH SCREENING COMPLETE")
    print("="*70)
    print(f"‚úÖ Passed: {passed_count}")
    print(f"‚ùå Failed: {failed_count}")
    print(f"‚ö†Ô∏è Errors: {error_count}")
    print(f"Total Processed: {len(results)}\n")

    return df

"""### 4.3. Test the Tools

Let's test the tools with a real Malaysian stock.
"""

# Test with Bursa Malaysia Berhad (1818.KL)
test_data = get_stock_data('0338.KL')
print(f"Stock: {test_data.get('name')}")
print(f"Price: {test_data.get('currency')} {test_data.get('price')}")
print(f"PE Ratio: {test_data.get('pe_ratio')}")
print(f"ROE: {test_data.get('roe_pct', 'N/A')}%")
print(f"Dividend Yield: {test_data.get('dividend_yield_pct', 'N/A')}%")

"""## 5. Agent Definitions - Investment Analysis Team

### 5.1. Stock Screener Agent

This agent screens stocks based on your investment criteria.
"""

# =========================
# Agent 1: Stock Screener
# =========================

def stock_screener_agent(ticker: str, criteria: dict = None) -> dict:
    """
    Screen a stock against investment criteria.

    Args:
        ticker (str): Stock ticker (e.g., '1818.KL')
        criteria (dict): Screening criteria (optional, uses defaults if None)

    Returns:
        dict: Screening results with pass/fail for each criterion
    """
    log_agent_title_html("Stock Screener Agent", "üîç")

    # Default criteria
    if criteria is None:
        criteria = {
            'max_price': 1.00,
            'min_pe': 4,
            'max_pe': 15,
            'min_roe': 5,  # As percentage
            'min_eps': 0.01,
            'min_dividend_yield': 1,  # As percentage
            'min_market_cap': 50_000_000,  # RM 50M
            'min_volume': 50_000  # shares per day
        }

    log_tool_call_html("get_stock_data", f"ticker={ticker}")

    # Get stock data
    stock_data = get_stock_data(ticker)

    if 'error' in stock_data:
        log_tool_result_html(f"Error: {stock_data['error']}")
        return {'error': stock_data['error'], 'ticker': ticker}

    log_tool_result_html(f"Retrieved data for {stock_data['name']}")

    # Perform screening
    results = {
        'ticker': ticker,
        'name': stock_data['name'],
        'stock_data': stock_data,
        'screening_results': {},
        'passed': True
    }

    # Check each criterion
    checks = [
        ('price', stock_data['price'], '‚â§', criteria['max_price'], 'price'),
        ('pe_ratio', stock_data['pe_ratio'], '‚â•', criteria['min_pe'], 'min_pe_ratio'),
        ('pe_ratio', stock_data['pe_ratio'], '‚â§', criteria['max_pe'], 'max_pe_ratio'),
        ('roe', stock_data.get('roe_pct'), '‚â•', criteria['min_roe'], 'min_roe_pct'),
        ('eps', stock_data['eps'], '‚â•', criteria['min_eps'], 'min_eps'),
        ('dividend_yield', stock_data.get('dividend_yield_pct'), '‚â•', criteria['min_dividend_yield'], 'min_dividend_yield_pct'),
        ('market_cap', stock_data['market_cap'], '‚â•', criteria['min_market_cap'], 'min_market_cap'),
        ('volume', stock_data['avg_volume'], '‚â•', criteria['min_volume'], 'min_volume')
    ]

    for metric, value, operator, threshold, display_name in checks:
        if value is None:
            passed = False
            status = 'N/A'
        elif operator == '‚â§':
            passed = value <= threshold
            status = '‚úÖ Pass' if passed else '‚ùå Fail'
        elif operator == '‚â•':
            passed = value >= threshold
            status = '‚úÖ Pass' if passed else '‚ùå Fail'

        results['screening_results'][f"{display_name}_{operator}_{threshold}"] = {
            'metric': display_name,
            'value': value,
            'threshold': threshold,
            'operator': operator,
            'passed': passed,
            'status': status
        }

        if not passed:
            results['passed'] = False

    # Generate summary
    summary = f"""
Stock: {stock_data['name']} ({ticker})
Overall Screening: {'‚úÖ PASSED all criteria' if results['passed'] else '‚ùå FAILED screening'}

Screening Results:
"""
    for key, check in results['screening_results'].items():
        summary += f"  {check['status']} {check['metric']}: {check['value']} {check['operator']} {check['threshold']}\n"

    log_final_summary_html(summary)

    return results

print("‚úÖ Stock Screener Agent defined")

"""### 5.2. Fundamental Analyst Agent

This agent evaluates profitability, financial health, and valuation metrics.
"""

# =========================
# Agent 2: Fundamental Analyst
# =========================

def fundamental_analyst_agent(stock_data: dict) -> dict:
    """
    Analyze fundamental metrics and generate investment yardstick scores.

    Args:
        stock_data (dict): Stock data from screener agent

    Returns:
        dict: Scores for fundamentals, financial health, and valuation
    """
    log_agent_title_html("Fundamental Analyst Agent", "üìà")

    prompt = f"""
You are a fundamental stock analyst. Analyze the following stock data and score it on these categories:

1. Fundamentals & Profitability (max 20 points)
   - ROE: {stock_data.get('roe_pct', 'N/A')}%
   - EPS: {stock_data.get('eps', 'N/A')}
   - Profit Margin: {stock_data.get('profit_margin', 'N/A')}
   - Operating Margin: {stock_data.get('operating_margin', 'N/A')}

2. Financial Health & Solvency (max 15 points)
   - Debt-to-Equity: {stock_data.get('debt_to_equity', 'N/A')}
   - Current Ratio: {stock_data.get('current_ratio', 'N/A')}
   - Book Value: {stock_data.get('book_value', 'N/A')}

3. Valuation (max 20 points)
   - PE Ratio: {stock_data.get('pe_ratio', 'N/A')}
   - Price-to-Book: {stock_data.get('price_to_book', 'N/A')}
   - Price-to-Sales: {stock_data.get('price_to_sales', 'N/A')}

Stock: {stock_data.get('name', 'N/A')}
Sector: {stock_data.get('sector', 'N/A')}
Industry: {stock_data.get('industry', 'N/A')}

Respond ONLY with valid JSON in this format:
{{
  "fundamentals_score": <0-20>,
  "fundamentals_analysis": "Brief analysis",
  "financial_health_score": <0-15>,
  "financial_health_analysis": "Brief analysis",
  "valuation_score": <0-20>,
  "valuation_analysis": "Brief analysis",
  "total_score": <sum of above>,
  "overall_assessment": "Brief overall summary"
}}
"""

    log_tool_call_html("gemini_analysis", "fundamental analysis")

    try:
        response = model.generate_content(prompt)
        text = response.text.strip()

        # Extract JSON
        json_match = re.search(r'\{.*\}', text, re.DOTALL)
        if json_match:
            result = json.loads(json_match.group(0))
            log_tool_result_html(f"Fundamental Score: {result.get('total_score', 0)}/55")
            log_final_summary_html(result.get('overall_assessment', 'Analysis complete'))
            return result
        else:
            return {"error": "No JSON in response", "raw": text}
    except Exception as e:
        return {"error": str(e)}

print("‚úÖ Fundamental Analyst Agent defined")

"""### 5.3. Business Moat Analyst Agent

This agent researches competitive advantages and business moats.
"""

# =========================
# Agent 3: Business Moat Analyst
# =========================

def business_moat_analyst_agent(stock_data: dict) -> dict:
    """
    Research business moat and competitive advantages.

    Args:
        stock_data (dict): Stock data

    Returns:
        dict: Moat score and analysis
    """
    log_agent_title_html("Business Moat Analyst Agent", "üè∞")

    company_name = stock_data.get('name', '')
    ticker = stock_data.get('ticker', '')

    # Search for business moat information
    search_query = f"{company_name} competitive advantage business moat Malaysia"
    log_tool_call_html("search_company_info", search_query)

    search_results = search_company_info(search_query, max_results=5)
    log_tool_result_html(f"Found {len(search_results)} articles")

    # Compile search content
    research_content = "\n\n".join([
        f"Source: {r['title']}\n{r['content']}"
        for r in search_results if 'error' not in r
    ])

    prompt = f"""
You are a business analyst evaluating competitive moats.

Company: {company_name} ({ticker})
Sector: {stock_data.get('sector', 'N/A')}
Industry: {stock_data.get('industry', 'N/A')}

Business Summary:
{stock_data.get('summary', 'N/A')}

Research from web:
{research_content[:3000]}

Score the business moat (max 15 points) based on:
- Brand strength and customer loyalty
- Network effects
- Cost advantages
- Regulatory barriers
- Switching costs
- Intangible assets (patents, licenses)

Respond ONLY with valid JSON:
{{
  "moat_score": <0-15>,
  "moat_type": "Primary moat type (e.g., 'Brand', 'Network', 'Cost', 'Regulatory')",
  "strengths": ["List of competitive advantages"],
  "weaknesses": ["List of competitive threats"],
  "analysis": "Detailed moat analysis"
}}
"""

    log_tool_call_html("gemini_analysis", "moat analysis")

    try:
        response = model.generate_content(prompt)
        text = response.text.strip()

        json_match = re.search(r'\{.*\}', text, re.DOTALL)
        if json_match:
            result = json.loads(json_match.group(0))
            log_tool_result_html(f"Moat Score: {result.get('moat_score', 0)}/15")
            log_final_summary_html(f"Moat Type: {result.get('moat_type', 'N/A')}\n\n{result.get('analysis', '')}")
            return result
        else:
            return {"error": "No JSON in response", "raw": text}
    except Exception as e:
        return {"error": str(e)}

print("‚úÖ Business Moat Analyst Agent defined")

"""### 5.4. Dividend & Cash Flow Analyst Agent

This agent evaluates dividend sustainability and cash flow quality.
"""

# =========================
# Agent 4: Dividend & Cash Flow Analyst
# =========================

def dividend_cashflow_analyst_agent(stock_data: dict) -> dict:
    """
    Analyze dividend sustainability and cash flow.

    Args:
        stock_data (dict): Stock data

    Returns:
        dict: Dividend score and analysis
    """
    log_agent_title_html("Dividend & Cash Flow Analyst Agent", "üí∞")

    ticker = stock_data.get('ticker', '')

    # Get dividend history
    log_tool_call_html("get_dividend_history", ticker)

    try:
        stock = yf.Ticker(ticker)
        dividends = stock.dividends

        if not dividends.empty:
            recent_dividends = dividends.tail(10).to_dict()
            dividend_info = f"Recent dividends: {len(dividends)} payments in history"
        else:
            recent_dividends = {}
            dividend_info = "No dividend history available"

        log_tool_result_html(dividend_info)

    except Exception as e:
        recent_dividends = {}
        dividend_info = f"Error fetching dividends: {str(e)}"

    prompt = f"""
You are a dividend and cash flow analyst.

Company: {stock_data.get('name', 'N/A')}

Dividend Metrics:
- Dividend Yield: {stock_data.get('dividend_yield_pct', 'N/A')}%
- Payout Ratio: {stock_data.get('payout_ratio', 'N/A')}
- Dividend Rate: {stock_data.get('dividend_rate', 'N/A')}

Financial Metrics:
- EPS: {stock_data.get('eps', 'N/A')}
- Profit Margin: {stock_data.get('profit_margin', 'N/A')}

Dividend History Info:
{dividend_info}

Score cash flow & dividends (max 15 points) based on:
- Dividend yield and consistency
- Payout ratio sustainability (40-60% is healthy)
- Dividend growth trend
- Coverage by earnings

Respond ONLY with valid JSON:
{{
  "dividend_score": <0-15>,
  "dividend_sustainability": "High/Medium/Low",
  "payout_ratio_assessment": "Assessment of payout ratio",
  "analysis": "Detailed dividend analysis"
}}
"""

    log_tool_call_html("gemini_analysis", "dividend analysis")

    try:
        response = model.generate_content(prompt)
        text = response.text.strip()

        json_match = re.search(r'\{.*\}', text, re.DOTALL)
        if json_match:
            result = json.loads(json_match.group(0))
            log_tool_result_html(f"Dividend Score: {result.get('dividend_score', 0)}/15")
            log_final_summary_html(f"Sustainability: {result.get('dividend_sustainability', 'N/A')}\n\n{result.get('analysis', '')}")
            return result
        else:
            return {"error": "No JSON in response", "raw": text}
    except Exception as e:
        return {"error": str(e)}

print("‚úÖ Dividend & Cash Flow Analyst Agent defined")

"""### 5.5. Investment Report Agent

This agent compiles all analysis into an executive investment report.
"""

# =========================
# Agent 5: Investment Report Generator
# =========================

def investment_report_agent(
    stock_data: dict,
    screening_results: dict,
    fundamental_analysis: dict,
    moat_analysis: dict,
    dividend_analysis: dict,
    output_path: str = None
) -> str:
    """
    Generate comprehensive investment report.

    Args:
        stock_data: Stock financial data
        screening_results: Screening pass/fail results
        fundamental_analysis: Fundamental scores
        moat_analysis: Moat scores
        dividend_analysis: Dividend scores
        output_path: Path to save markdown report

    Returns:
        str: Path to saved report
    """
    log_agent_title_html("Investment Report Agent", "üìã")

    # Calculate total investment yardstick score
    # Note: Management & Liquidity scoring (15 points) is simplified here
    management_score = 8  # Placeholder (would need more research)
    liquidity_score = 5 if stock_data.get('avg_volume', 0) >= 50000 else 2

    total_score = (
        fundamental_analysis.get('fundamentals_score', 0) +
        fundamental_analysis.get('financial_health_score', 0) +
        fundamental_analysis.get('valuation_score', 0) +
        moat_analysis.get('moat_score', 0) +
        dividend_analysis.get('dividend_score', 0) +
        management_score +
        liquidity_score
    )

    # Determine recommendation
    if total_score >= 80:
        recommendation = "Strong Buy üü¢"
        action = "BUY"
    elif total_score >= 60:
        recommendation = "Buy üü°"
        action = "BUY"
    elif total_score >= 40:
        recommendation = "Hold ‚ö™"
        action = "HOLD"
    else:
        recommendation = "Avoid üî¥"
        action = "AVOID"

    # Build markdown report
    markdown_content = f"""# üìä Investment Analysis Report

**Stock:** {stock_data.get('name', 'N/A')} ({stock_data.get('ticker', 'N/A')})
**Sector:** {stock_data.get('sector', 'N/A')} | **Industry:** {stock_data.get('industry', 'N/A')}
**Analysis Date:** {datetime.now().strftime('%Y-%m-%d')}

---

## Executive Summary

**Investment Yardstick Score:** {total_score}/100
**Recommendation:** {recommendation}
**Action:** **{action}**

---

## Screening Results

**Overall Screening:** {'‚úÖ PASSED all criteria' if screening_results.get('passed', False) else '‚ùå FAILED screening'}

| Criterion | Value | Threshold | Status |
|-----------|-------|-----------|--------|
"""

    for key, check in screening_results.get('screening_results', {}).items():
        markdown_content += f"| {check['metric']} | {check['value']} | {check['operator']} {check['threshold']} | {check['status']} |\n"

    markdown_content += f"""

---

## Investment Yardstick Breakdown

### 1. Fundamentals & Profitability ({fundamental_analysis.get('fundamentals_score', 0)}/20)

- **ROE:** {stock_data.get('roe_pct', 'N/A')}%
- **EPS:** {stock_data.get('eps', 'N/A')}
- **Profit Margin:** {stock_data.get('profit_margin', 'N/A')}

**Analysis:** {fundamental_analysis.get('fundamentals_analysis', 'N/A')}

### 2. Financial Health & Solvency ({fundamental_analysis.get('financial_health_score', 0)}/15)

- **Debt-to-Equity:** {stock_data.get('debt_to_equity', 'N/A')}
- **Current Ratio:** {stock_data.get('current_ratio', 'N/A')}
- **Book Value:** {stock_data.get('book_value', 'N/A')}

**Analysis:** {fundamental_analysis.get('financial_health_analysis', 'N/A')}

### 3. Valuation ({fundamental_analysis.get('valuation_score', 0)}/20)

- **PE Ratio:** {stock_data.get('pe_ratio', 'N/A')}
- **Price-to-Book:** {stock_data.get('price_to_book', 'N/A')}
- **Price-to-Sales:** {stock_data.get('price_to_sales', 'N/A')}

**Analysis:** {fundamental_analysis.get('valuation_analysis', 'N/A')}

### 4. Business Moat ({moat_analysis.get('moat_score', 0)}/15)

- **Moat Type:** {moat_analysis.get('moat_type', 'N/A')}
- **Strengths:** {', '.join(moat_analysis.get('strengths', []))}
- **Weaknesses:** {', '.join(moat_analysis.get('weaknesses', []))}

**Analysis:** {moat_analysis.get('analysis', 'N/A')}

### 5. Cash Flow & Dividends ({dividend_analysis.get('dividend_score', 0)}/15)

- **Dividend Yield:** {stock_data.get('dividend_yield_pct', 'N/A')}%
- **Payout Ratio:** {stock_data.get('payout_ratio', 'N/A')}
- **Sustainability:** {dividend_analysis.get('dividend_sustainability', 'N/A')}

**Analysis:** {dividend_analysis.get('analysis', 'N/A')}

### 6. Management & Outlook ({management_score}/10)

*Simplified scoring based on available data*

### 7. Liquidity ({liquidity_score}/5)

- **Avg Volume:** {stock_data.get('avg_volume', 'N/A'):,} shares/day

---

## Final Recommendation

**{action}** - {recommendation}

{fundamental_analysis.get('overall_assessment', '')}

---

*Report generated by Stock Review Workflow*
*Powered by Google Gemini 2.0 Flash & Yahoo Finance*
"""

    if output_path is None:
        timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
        ticker_safe = stock_data.get('ticker', 'stock').replace('.', '_')
        output_path = f"investment_report_{ticker_safe}_{timestamp}.md"

    with open(output_path, 'w', encoding='utf-8') as f:
        f.write(markdown_content)

    log_final_summary_html(f"Investment report generated!\n\nTotal Score: {total_score}/100\nRecommendation: {recommendation}\n\nSaved to: {output_path}")

    return output_path

print("‚úÖ Investment Report Agent defined")

"""## 6. Visualization Functions"""

# =========================
# Visualization: Investment Yardstick Chart
# =========================

def create_yardstick_visualization(
    fundamental_analysis: dict,
    moat_analysis: dict,
    dividend_analysis: dict,
    stock_data: dict,
    output_path: str = None
) -> str:
    """
    Create a bar chart showing investment yardstick scores.
    """
    # Prepare data
    categories = [
        'Fundamentals\n(20)',
        'Financial Health\n(15)',
        'Valuation\n(20)',
        'Business Moat\n(15)',
        'Dividends\n(15)',
        'Management\n(10)',
        'Liquidity\n(5)'
    ]

    scores = [
        fundamental_analysis.get('fundamentals_score', 0),
        fundamental_analysis.get('financial_health_score', 0),
        fundamental_analysis.get('valuation_score', 0),
        moat_analysis.get('moat_score', 0),
        dividend_analysis.get('dividend_score', 0),
        8,  # Placeholder
        5 if stock_data.get('avg_volume', 0) >= 50000 else 2
    ]

    max_scores = [20, 15, 20, 15, 15, 10, 5]

    # Create figure
    fig, ax = plt.subplots(figsize=(12, 6))

    x_pos = range(len(categories))

    # Plot bars
    bars = ax.bar(x_pos, scores, color=['#10b981' if s/m >= 0.7 else '#f59e0b' if s/m >= 0.5 else '#ef4444'
                                          for s, m in zip(scores, max_scores)])

    # Add max score lines
    for i, (score, max_score) in enumerate(zip(scores, max_scores)):
        ax.plot([i-0.4, i+0.4], [max_score, max_score], 'k--', alpha=0.5, linewidth=1)
        ax.text(i, score + 0.5, f"{score:.0f}", ha='center', va='bottom', fontweight='bold')

    ax.set_xlabel('Category', fontsize=12, fontweight='bold')
    ax.set_ylabel('Score', fontsize=12, fontweight='bold')
    ax.set_title(f'Investment Yardstick - {stock_data.get("name", "Stock")}\nTotal: {sum(scores):.0f}/100',
                 fontsize=14, fontweight='bold')
    ax.set_xticks(x_pos)
    ax.set_xticklabels(categories)
    ax.grid(axis='y', alpha=0.3)

    if output_path is None:
        timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
        ticker_safe = stock_data.get('ticker', 'stock').replace('.', '_')
        output_path = f"yardstick_{ticker_safe}_{timestamp}.png"

    plt.tight_layout()
    plt.savefig(output_path, dpi=150, bbox_inches='tight')
    plt.close()

    print(f"‚úÖ Yardstick chart saved to: {output_path}")
    return output_path

print("‚úÖ Visualization functions loaded")

"""## 7. Full Pipeline Function

This function orchestrates all agents to analyze a stock end-to-end.
"""

# =========================
# Full Stock Analysis Pipeline
# =========================

def run_stock_analysis_pipeline(ticker: str) -> dict:
    """
    Run complete stock analysis pipeline.

    Args:
        ticker (str): Stock ticker (e.g., '1818.KL')

    Returns:
        dict: Complete analysis results
    """
    print("\n" + "="*70)
    print("üöÄ STOCK ANALYSIS PIPELINE")
    print("="*70 + "\n")

    # Stage 1: Screening
    screening_results = stock_screener_agent(ticker)

    if 'error' in screening_results:
        print(f"\n‚ùå Error: {screening_results['error']}")
        return screening_results

    print("\n‚úÖ Stage 1/5 Complete: Stock Screening\n")

    stock_data = screening_results['stock_data']

    # Stage 2: Fundamental Analysis
    fundamental_analysis = fundamental_analyst_agent(stock_data)
    print("\n‚úÖ Stage 2/5 Complete: Fundamental Analysis\n")

    # Stage 3: Business Moat
    moat_analysis = business_moat_analyst_agent(stock_data)
    print("\n‚úÖ Stage 3/5 Complete: Business Moat Analysis\n")

    # Stage 4: Dividend & Cash Flow
    dividend_analysis = dividend_cashflow_analyst_agent(stock_data)
    print("\n‚úÖ Stage 4/5 Complete: Dividend & Cash Flow Analysis\n")

    # Stage 5: Generate Report
    report_path = investment_report_agent(
        stock_data=stock_data,
        screening_results=screening_results,
        fundamental_analysis=fundamental_analysis,
        moat_analysis=moat_analysis,
        dividend_analysis=dividend_analysis
    )
    print("\n‚úÖ Stage 5/5 Complete: Investment Report Generated\n")

    # Create visualization
    chart_path = create_yardstick_visualization(
        fundamental_analysis=fundamental_analysis,
        moat_analysis=moat_analysis,
        dividend_analysis=dividend_analysis,
        stock_data=stock_data
    )

    print("\n" + "="*70)
    print("üéâ ANALYSIS COMPLETE!")
    print("="*70)
    print(f"\nüìÑ Report: {report_path}")
    print(f"üìä Chart: {chart_path}\n")

    return {
        'ticker': ticker,
        'screening_results': screening_results,
        'fundamental_analysis': fundamental_analysis,
        'moat_analysis': moat_analysis,
        'dividend_analysis': dividend_analysis,
        'report_path': report_path,
        'chart_path': chart_path
    }

print("‚úÖ Stock analysis pipeline function defined")

# =========================
# Section 9: Stock Discovery Function
# =========================

def discover_stocks(
    criteria: dict = None,
    max_stocks_to_scan: int = 50,
    analyze_top_n: int = 3
) -> dict:
    """
    Discover stocks that meet investment criteria and analyze the best ones.

    Args:
        criteria (dict): Screening criteria (uses defaults if None)
        max_stocks_to_scan (int): How many stocks to screen
        analyze_top_n (int): How many passing stocks to fully analyze

    Returns:
        dict: Discovery results with screening data and full analysis of top stocks
    """
    print("\n" + "="*70)
    print("üîé STOCK DISCOVERY PIPELINE")
    print("="*70 + "\n")

    # Step 1: Get stock list
    print("üìã Step 1: Getting Malaysian stock list...")
    stock_list = get_malaysian_stock_list(use_klci_components=True)
    print(f"Found {len(stock_list)} stocks to screen\n")

    # Step 2: Batch screening
    print("üîç Step 2: Screening stocks against criteria...")
    screening_df = batch_screen_stocks(
        ticker_list=stock_list,
        criteria=criteria,
        # max_stocks_to_scan=max_stocks_to_scan, # Removed this argument
        verbose=True
    )

    # Step 3: Filter passing stocks
    passing_stocks = screening_df[screening_df['passed'] == True].copy()

    if len(passing_stocks) == 0:
        print("\n‚ö†Ô∏è No stocks passed the screening criteria.")
        print("Consider relaxing your criteria (e.g., increase max_price, adjust PE range)")
        return {
            'screening_df': screening_df,
            'passing_stocks': passing_stocks,
            'analyzed_stocks': []
        }

    # Sort by investment attractiveness (simple heuristic)
    # Higher ROE, lower PE, higher dividend yield = better
    passing_stocks['attractiveness_score'] = (
        passing_stocks['roe_pct'].fillna(0) * 0.4 +
        (20 - passing_stocks['pe_ratio'].fillna(20)) * 0.3 +
        passing_stocks['dividend_yield_pct'].fillna(0) * 0.3
    )

    passing_stocks = passing_stocks.sort_values('attractiveness_score', ascending=False)

    print(f"\n‚úÖ {len(passing_stocks)} stocks passed screening!\n")
    print("Top candidates:")
    print(passing_stocks[['ticker', 'name', 'price', 'pe_ratio', 'roe_pct', 'dividend_yield_pct']].head(10).to_string())

    # Step 4: Full analysis of top N stocks
    top_stocks = passing_stocks.head(analyze_top_n)
    analyzed_results = []

    print(f"\n\nüìà Step 3: Running full analysis on top {analyze_top_n} stocks...\n")

    for idx, row in top_stocks.iterrows():
        ticker = row['ticker']
        print(f"\n{'='*70}")
        print(f"Analyzing {ticker} - {row['name']}")
        print(f"{'='*70}\n")

        try:
            result = run_stock_analysis_pipeline(ticker)
            analyzed_results.append(result)
        except Exception as e:
            print(f"Error analyzing {ticker}: {str(e)}")
            continue

    print("\n" + "="*70)
    print("üéâ STOCK DISCOVERY COMPLETE!")
    print("="*70)
    print(f"\nüìä Screened: {len(screening_df)} stocks")
    print(f"‚úÖ Passed: {len(passing_stocks)} stocks")
    print(f"üìà Fully Analyzed: {len(analyzed_results)} stocks\n")

    return {
        'screening_df': screening_df,
        'passing_stocks': passing_stocks,
        'analyzed_stocks': analyzed_results
    }

"""## 8. Example Usage

### 8.1. Analyze Bursa Malaysia Berhad (1818.KL)
"""

# Run analysis on Bursa Malaysia Berhad
results = run_stock_analysis_pipeline('0338.KL')

# Discover stocks matching criteria
discovery_results = discover_stocks(
criteria={
    'max_price': 1.00,
    'min_pe': 4,
    'max_pe': 15,
    'min_roe': 5,  # As percentage
    'min_eps': 0.01,
    'min_dividend_yield': 1,  # As percentage
    'min_market_cap': 50_000_000,  # RM 50M
    'min_volume': 50_000  # shares per day
},
max_stocks_to_scan=50,
analyze_top_n=3)

"""### 8.2. View the Investment Report"""

# For specific stock analysis:
print(f"\nReport: {results['report_path']}")
print(f"Chart: {results['chart_path']}")

# Load and display the markdown report
with open(results['report_path'], 'r', encoding='utf-8') as f:
    md_content = f.read()

display(Markdown(md_content))

# For stock discovery:
print(f"\nPassing stocks: {len(discovery_results['passing_stocks'])}")
print(discovery_results['passing_stocks'][['ticker', 'name', 'price', 'pe_ratio']])

"""### 8.3. Display the Yardstick Chart"""

# Display the chart
from IPython.display import Image as IPImage
display(IPImage(filename=results['chart_path']))

"""## 9. Analyze Multiple Stocks"""

# Example: Analyze multiple Malaysian stocks
# Note: Replace with actual tickers that meet your screening criteria

tickers_to_analyze = [
    '0338.KL',  # Bursa Malaysia
    '5296.KL',  # MISC Berhad
    '4715.KL',  # MISC Berhad
    '1619.KL',  # MISC Berhad
    '5306.KL',  # MISC Berhad
    # Add more tickers here
]

all_results = []

for ticker in tickers_to_analyze:
    print(f"\n{'='*70}")
    print(f"Analyzing {ticker}...")
    print(f"{'='*70}\n")

    try:
        result = run_stock_analysis_pipeline(ticker)
        all_results.append(result)
    except Exception as e:
        print(f"Error analyzing {ticker}: {str(e)}")
        continue

"""## 10. Summary

### ‚úÖ What You've Built:

A production-ready **multi-agent stock analysis system** that:

1. **Screens stocks** against your investment criteria (Price, PE, ROE, DY, etc.)
2. **Analyzes fundamentals** (profitability, financial health, valuation)
3. **Researches business moats** using web search
4. **Evaluates dividends** and cash flow sustainability
5. **Generates investment reports** with actionable buy/hold/avoid recommendations
6. **Creates visualizations** of investment yardstick scores

### üìä Data Sources:

- **Yahoo Finance** (via yfinance) - Real Malaysian stock data
- **Tavily Search** - Qualitative research on moats and competitive position
- **Gemini 2.0 Flash** - AI-powered analysis and scoring

### üéØ Investment Yardstick (7 Categories):

1. Fundamentals & Profitability (20%)
2. Financial Health & Solvency (15%)
3. Valuation (20%)
4. Business Moat (15%)
5. Cash Flow & Dividends (15%)
6. Management & Outlook (10%)
7. Liquidity (5%)

**Total Score: 0-100**
- 80-100: Strong Buy üü¢
- 60-79: Buy üü°
- 40-59: Hold ‚ö™
- 0-39: Avoid üî¥

---

**Congratulations! üéâ**

You've successfully built a multi-agent investment analysis pipeline that combines real market data with AI-powered research to generate professional investment reports!
"""