# -*- coding: utf-8 -*-
"""Sales Dashbaord Agent

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1ssz7RkCySo4fhzkLdCs5c7gCgkP7ypv7
"""

# Install required packages
!pip install -q tinydb google-generativeai pandas python-dotenv

# Import libraries
from __future__ import annotations
import json
import pandas as pd
import re
import io
import sys
import traceback
from typing import Any, Dict, Optional
from tinydb import TinyDB, Query, where
from datetime import datetime
from IPython.display import HTML, display
import google.generativeai as genai

print("✅ All libraries imported successfully!")

# Option 1: Direct API key (for testing)
GEMINI_API_KEY = "AIzaSyBc6_k7gWDAwo0n442rOOqY8UTn_u133ME0"  # Replace with your key

def print_html(content: str, title: str = ""):
    """
    Display formatted HTML output in Colab.
    """
    html = f"""
    <div style="border:1px solid #3B82F6; border-left:6px solid #3B82F6;
                background:#EFF6FF; border-radius:8px; padding:16px;
                margin:10px 0; font-family:monospace;">
        <h4 style="margin-top:0; color:#1E40AF;">{title}</h4>
        <pre style="white-space: pre-wrap; word-wrap: break-word;">{content}</pre>
    </div>
    """
    display(HTML(html))

print("✅ Utility functions loaded!")

# Upload your CSV file
from google.colab import files

print("📁 Please upload your dataset.csv file:")
uploaded = files.upload()

# Get the uploaded filename
csv_filename = list(uploaded.keys())[0]
print(f"✅ File uploaded: {csv_filename}")

# Load CSV into pandas
df = pd.read_csv(csv_filename)

# Clean column names (remove spaces)
df.columns = df.columns.str.strip()

# Convert to proper data types
df['Order_Date'] = pd.to_datetime(df['Order_Date'], format='%m-%d-%y', errors='coerce')
df['Unit_Price'] = pd.to_numeric(df['Unit_Price'], errors='coerce')
df['Revenue'] = pd.to_numeric(df['Revenue'], errors='coerce')
df['Profit'] = pd.to_numeric(df['Profit'], errors='coerce')
df['Quantity'] = pd.to_numeric(df['Quantity'], errors='coerce')

# Preview the data
print(f"📊 Dataset loaded: {len(df)} orders")
print(f"📅 Date range: {df['Order_Date'].min()} to {df['Order_Date'].max()}")
print(f"💰 Total Revenue: ${df['Revenue'].sum():,.2f}")
print(f"📈 Total Profit: ${df['Profit'].sum():,.2f}")
print("\n" + "="*60)
df.head()

def create_sales_database(df: pd.DataFrame) -> tuple:
    """
    Convert DataFrame to TinyDB and return db and table objects.
    """
    # Create in-memory database
    from tinydb.storages import MemoryStorage
    db = TinyDB(storage=MemoryStorage)  # Use MemoryStorage for in-memory mode
    orders_tbl = db.table('orders')

    # Convert DataFrame to records
    # Convert datetime to string for JSON serialization
    df_copy = df.copy()
    df_copy['Order_Date'] = df_copy['Order_Date'].dt.strftime('%Y-%m-%d')

    records = df_copy.to_dict('records')

    # Insert all records
    orders_tbl.insert_multiple(records)

    return db, orders_tbl

# Create database
db, orders_tbl = create_sales_database(df)

print(f"✅ TinyDB created with {len(orders_tbl)} orders")
print("\n📋 Sample record:")
print_html(json.dumps(orders_tbl.all()[0], indent=2), "First Order Record")

# Calculate total revenue by region
region_revenue = {}
for order in orders_tbl.all():
    region = order['Region']
    revenue = order['Revenue']
    if region in region_revenue:
        region_revenue[region] += revenue
    else:
        region_revenue[region] = revenue

# Convert to a DataFrame for better display and sorting
region_revenue_df = pd.DataFrame(list(region_revenue.items()), columns=['Region', 'Total Revenue'])

# Sort by Total Revenue
region_revenue_df = region_revenue_df.sort_values(by='Total Revenue', ascending=False)

# Display the results
print("📊 Total Revenue by Region:")
print_html(region_revenue_df.to_html(index=False, formatters={'Total Revenue': '${:,.2f}'.format}), "Total Revenue by Region")

def build_schema_block(orders_tbl) -> str:
    """
    Generate a human-readable schema description with sample data.
    """
    sample_records = orders_tbl.all()[:3]

    schema = f"""
=== ORDERS TABLE (orders_tbl) ===
Total Records: {len(orders_tbl)}

Schema:
- Order_ID (int): Unique order identifier
- Order_Date (string): Date in YYYY-MM-DD format
- Customer_Name (string): Name of customer
- City (string): Customer city
- State (string): Customer state
- Region (string): Geographic region (East, West, Centre, South)
- Country (string): Country (United States)
- Category (string): Main product category (Electronics, Clothing & Apparel, Accessories, Home & Furniture)
- Sub_Category (string): Detailed sub-category
- Product_Name (string): Specific product name
- Quantity (int): Number of units ordered
- Unit_Price (float): Price per unit in USD
- Revenue (float): Total revenue (Quantity × Unit_Price)
- Profit (float): Profit from this order

Sample Records:
{json.dumps(sample_records, indent=2)}
"""
    return schema

schema_block = build_schema_block(orders_tbl)
print_html(schema_block, "Database Schema")

SALES_AGENT_PROMPT = """You are a senior sales data analyst. PLAN BY WRITING PYTHON CODE USING TINYDB.

Database Schema & Samples (read-only):
{schema_block}

Execution Environment (already imported/provided):
- Variables: db, orders_tbl  # TinyDB objects
- Libraries: Query (from tinydb), datetime, re
- Natural language: user_request: str  # the original user question

PLANNING RULES (critical):
- Derive ALL filters/parameters from user_request (date ranges, regions, categories, products, customers)
- Build TinyDB queries dynamically with Query()
- For date filtering: use string comparison (dates are stored as YYYY-MM-DD strings)
- For aggregations: use Python's sum(), len(), max(), min(), statistics module
- Be conservative: this is READ-ONLY analytics (no mutations allowed)

HUMAN RESPONSE REQUIREMENT (hard):
- You MUST set a variable named `answer_text` (type str) with a concise, business-friendly answer (2-3 sentences max)
- Include relevant numbers, comparisons, and insights
- If no data matches, suggest alternative queries
- Format currency as "$X,XXX.XX" and percentages as "XX.X%"

OUTPUT CONTRACT:
- Return ONLY executable Python between these tags (no extra text):
  <execute_python>
  # your python code here
  </execute_python>

CODE CHECKLIST:
1) Parse the user_request to understand what's being asked
2) Build TinyDB query with appropriate filters
3) Perform calculations (sums, averages, counts, etc.)
4) ALWAYS set `answer_text` with a human-friendly response
5) Optional: set `answer_data` (list/dict) for structured results
6) Print a brief log to stdout for debugging

EXAMPLE PATTERNS:

# Total revenue by region
Item = Query()
orders = orders_tbl.all()
west_revenue = sum(o['Revenue'] for o in orders if o['Region'] == 'West')
answer_text = f"West region generated ${{west_revenue:,.2f}} in total revenue."

# Top 5 products by profit
from collections import defaultdict
product_profit = defaultdict(float)
for order in orders_tbl.all():
    product_profit[order['Product_Name']] += order['Profit']
top_5 = sorted(product_profit.items(), key=lambda x: x[1], reverse=True)[:5]
answer_text = f"Top product: {{top_5[0][0]}} with ${{top_5[0][1]:,.2f}} profit."

# Date filtering
Item = Query()
nov_orders = orders_tbl.search((Item.Order_Date >= '2024-11-01') & (Item.Order_Date <= '2024-11-30'))
nov_revenue = sum(o['Revenue'] for o in nov_orders)
answer_text = f"November 2024 revenue: ${{nov_revenue:,.2f}} from {{len(nov_orders)}} orders."

Constraints:
- Use TinyDB Query for filtering
- Keep code clear and commented
- Always provide meaningful insights, not just raw numbers

User request:
{question}
"""

print("✅ Agent prompt template loaded!")

def generate_llm_code(
    prompt: str,
    *,
    orders_tbl,
    model: str = "gemini-2.0-flash-exp",
    temperature: float = 0.3,
) -> str:
    """
    Ask Gemini to produce a plan-with-code response.
    Returns the FULL assistant content (including surrounding text and tags).
    """
    schema_block = build_schema_block(orders_tbl)
    full_prompt = SALES_AGENT_PROMPT.format(schema_block=schema_block, question=prompt)

    # Configure Gemini model
    generation_config = {
        "temperature": temperature,
        "top_p": 0.95,
        "top_k": 40,
        "max_output_tokens": 8192,
    }

    model_instance = genai.GenerativeModel(
        model_name=model,
        generation_config=generation_config,
    )

    # Generate response
    response = model_instance.generate_content(full_prompt)

    return response.text

print("✅ Code generation function loaded!")

def _extract_execute_block(text: str) -> str:
    """
    Returns the Python code inside <execute_python>...</execute_python>.
    If no tags are found, assumes 'text' is already raw Python code.
    Also removes markdown code block delimiters if present.
    """
    if not text:
        raise RuntimeError("Empty content passed to code executor.")

    # First, try to extract the content within <execute_python> tags
    m = re.search(r"<execute_python>(.*?)</execute_python>", text, re.DOTALL | re.IGNORECASE)
    code = m.group(1).strip() if m else text.strip()

    # Then, remove markdown code block delimiters if they exist
    # This handles cases where the LLM includes markdown fences inside the execute_python block
    code = re.sub(r"```python\n?", "", code, count=1)
    code = re.sub(r"```\n?", "", code)

    # Clean up leading/trailing whitespace and empty lines
    code_lines = code.splitlines()
    cleaned_lines = [line for line in code_lines if line.strip()] # Remove empty lines
    code = "\n".join(cleaned_lines).strip() # Join back and strip leading/trailing whitespace

    return code


def execute_generated_code(
    code_or_content: str,
    *,
    db,
    orders_tbl,
    user_request: Optional[str] = None,
) -> Dict[str, Any]:
    """
    Execute code in a controlled namespace.
    Accepts either raw Python code OR full content with <execute_python> tags.
    Returns execution results: stdout, error, and extracted answer.
    """
    # Extract code
    code = _extract_execute_block(code_or_content)

    # Safe globals (only allow safe operations)
    SAFE_GLOBALS = {
        "Query": Query,
        "datetime": datetime,
        "user_request": user_request or "",
        "re": re,
        "sum": sum,
        "len": len,
        "max": max,
        "min": min,
        "sorted": sorted,
        "defaultdict": __import__('collections').defaultdict,
    }

    SAFE_LOCALS = {
        "db": db,
        "orders_tbl": orders_tbl,
    }

    # Capture stdout
    _stdout_buf, _old_stdout = io.StringIO(), sys.stdout
    sys.stdout = _stdout_buf
    err_text = None

    try:
        exec(code, SAFE_GLOBALS, SAFE_LOCALS)
    except Exception:
        err_text = traceback.format_exc()
    finally:
        sys.stdout = _old_stdout

    printed = _stdout_buf.getvalue().strip()

    # Extract answer variables
    answer = (
        SAFE_LOCALS.get("answer_text")
        or SAFE_LOCALS.get("answer_data")
        or "No answer generated"
    )

    return {
        "code": code,
        "stdout": printed,
        "error": err_text,
        "answer": answer,
    }

print("✅ Code execution function loaded!")

def sales_dashboard_agent(
    question: str,
    *,
    db,
    orders_tbl,
    model: str = "gemini-2.0-flash-exp",
    temperature: float = 0.3,
    verbose: bool = True,
) -> dict:
    """
    End-to-end sales dashboard agent:
      1) Generate plan-as-code from question
      2) Execute in controlled namespace
      3) Return results with full transparency

    Returns:
      {
        "question": user question,
        "full_content": raw LLM response,
        "exec": {code, stdout, error, answer}
      }
    """
    if verbose:
        print_html(question, "💬 User Question")

    # Generate plan-as-code
    full_content = generate_llm_code(
        question,
        orders_tbl=orders_tbl,
        model=model,
        temperature=temperature,
    )

    if verbose:
        print_html(full_content, "🤖 Generated Plan (with Code)")

    # Execute the plan
    exec_res = execute_generated_code(
        full_content,
        db=db,
        orders_tbl=orders_tbl,
        user_request=question,
    )

    # Show results
    if verbose:
        if exec_res["error"]:
            print_html(exec_res["error"], "❌ Execution Error")
        else:
            print_html(exec_res["answer"], "✅ Answer")
            if exec_res["stdout"]:
                print_html(exec_res["stdout"], "📋 Debug Logs")

    return {
        "question": question,
        "full_content": full_content,
        "exec": exec_res,
    }

print("✅ Sales Dashboard Agent ready!")

# Configure the Gemini API with the API key
genai.configure(api_key=GEMINI_API_KEY)

print("✅ Gemini API configured!")

result = sales_dashboard_agent(
    "What were our total sales in November 2024?",
    db=db,
    orders_tbl=orders_tbl,
)

result = sales_dashboard_agent(
    "Which region generated the most profit last year?",
    db=db,
    orders_tbl=orders_tbl,
)

result = sales_dashboard_agent(
    "Which region generated the least profit last year?",
    db=db,
    orders_tbl=orders_tbl,
)

result = sales_dashboard_agent(
    "Show me the top 5 best-selling products by revenue",
    db=db,
    orders_tbl=orders_tbl,
)

result = sales_dashboard_agent(
    "Show me the top 5 best-selling products by quantity",
    db=db,
    orders_tbl=orders_tbl,
)

result = sales_dashboard_agent(
    "Show me the top 5 best-selling products by profit",
    db=db,
    orders_tbl=orders_tbl,
)

result = sales_dashboard_agent(
    "What's the average order value for each category?, can you sort in descending order?",
    db=db,
    orders_tbl=orders_tbl,
)

result = sales_dashboard_agent(
    "Which customer has spent the most money in electronics category?",
    db=db,
    orders_tbl=orders_tbl,
)

result = sales_dashboard_agent(
    "Top 5 customer has spent the most money in Accessories category?",
    db=db,
    orders_tbl=orders_tbl,
)

result = sales_dashboard_agent(
    "What is the profit margins for all products?",
    db=db,
    orders_tbl=orders_tbl,
)

result = sales_dashboard_agent(
    "What products have profit margins below 10%?",
    db=db,
    orders_tbl=orders_tbl,
)

result = sales_dashboard_agent(
    "What products have profit margins below 20%?",
    db=db,
    orders_tbl=orders_tbl,
)

result = sales_dashboard_agent(
    "What products have profit margins above 30%?",
    db=db,
    orders_tbl=orders_tbl,
)

result = sales_dashboard_agent(
    "can you show in bar chart products have profit margins above 30%?",
    db=db,
    orders_tbl=orders_tbl,
)

result = sales_dashboard_agent(
    "can you display in table format?",
    db=db,
    orders_tbl=orders_tbl,
)

result = sales_dashboard_agent(
    "can you show in table format products have profit margins above 30%?",
    db=db,
    orders_tbl=orders_tbl,
)

result = sales_dashboard_agent(
    "Can you display total revenue by month in line chart",
    db=db,
    orders_tbl=orders_tbl,
)

result = sales_dashboard_agent(
    "can you display top 5 customer by quantity in electronic category in bar chart?, please include label in your chart",
    db=db,
    orders_tbl=orders_tbl,
)

"""# Task
Modify the agent to generate visualizations.

## Update agent prompt

### Subtask:
Modify the `SALES_AGENT_PROMPT` to explicitly instruct the agent to generate Python code for creating visualizations (e.g., using Matplotlib or Seaborn) when a visualization is requested.

**Reasoning**:
Modify the SALES_AGENT_PROMPT to include instructions for generating visualization code using Matplotlib or Seaborn when requested by the user, ensuring necessary imports are included and the plot is either displayed or saved.
"""

SALES_AGENT_PROMPT = """You are a senior sales data analyst. PLAN BY WRITING PYTHON CODE USING TINYDB.

Database Schema & Samples (read-only):
{schema_block}

Execution Environment (already imported/provided):
- Variables: db, orders_tbl  # TinyDB objects
- Libraries: Query (from tinydb), datetime, re
- Natural language: user_request: str  # the original user question

PLANNING RULES (critical):
- Derive ALL filters/parameters from user_request (date ranges, regions, categories, products, customers)
- Build TinyDB queries dynamically with Query()
- For date filtering: use string comparison (dates are stored as YYYY-MM-DD strings)
- For aggregations: use Python's sum(), len(), max(), min(), statistics module
- Be conservative: this is READ-ONLY analytics (no mutations allowed)
- IF the user requests a visualization (e.g., "show in bar chart", "visualize", "plot"), GENERATE PYTHON CODE to create a plot using Matplotlib or Seaborn. Include necessary import statements (e.g., `import matplotlib.pyplot as plt`, `import seaborn as sns`). Ensure the plot is displayed or saved to a file.

HUMAN RESPONSE REQUIREMENT (hard):
- You MUST set a variable named `answer_text` (type str) with a concise, business-friendly answer (2-3 sentences max)
- Include relevant numbers, comparisons, and insights
- If no data matches, suggest alternative queries
- Format currency as "$X,XXX.XX" and percentages as "XX.X%"

OUTPUT CONTRACT:
- Return ONLY executable Python between these tags (no extra text):
  <execute_python>
  # your python code here
  </execute_python>

CODE CHECKLIST:
1) Parse the user_request to understand what's being asked
2) Build TinyDB query with appropriate filters
3) Perform calculations (sums, averages, counts, etc.)
4) ALWAYS set `answer_text` with a human-friendly response
5) Optional: set `answer_data` (list/dict) for structured results
6) Print a brief log to stdout for debugging
7) IF a visualization is requested, include Matplotlib/Seaborn code to generate and display/save the plot.

EXAMPLE PATTERNS:

# Total revenue by region
Item = Query()
orders = orders_tbl.all()
west_revenue = sum(o['Revenue'] for o in orders if o['Region'] == 'West')
answer_text = f"West region generated ${{west_revenue:,.2f}} in total revenue."

# Top 5 products by profit
from collections import defaultdict
product_profit = defaultdict(float)
for order in orders_tbl.all():
    product_profit[order['Product_Name']] += order['Profit']
top_5 = sorted(product_profit.items(), key=lambda x: x[1], reverse=True)[:5]
answer_text = f"Top product: {{top_5[0][0]}} with ${{top_5[0][1]:,.2f}} profit."

# Date filtering
Item = Query()
nov_orders = orders_tbl.search((Item.Order_Date >= '2024-11-01') & (Item.Order_Date <= '2024-11-30'))
nov_revenue = sum(o['Revenue'] for o in nov_orders)
answer_text = f"November 2024 revenue: ${{nov_revenue:,.2f}} from {{len(nov_orders)}} orders."

# Example Visualization Pattern (add this when visualization is requested)
# import matplotlib.pyplot as plt
# product_data = {'Product A': 1000, 'Product B': 1500} # Example data
# products = list(product_data.keys())
# revenue = list(product_data.values())
# plt.figure(figsize=(10, 6))
# plt.bar(products, revenue)
# plt.title('Revenue by Product')
# plt.xlabel('Product')
# plt.ylabel('Revenue ($)')
# plt.show()

Constraints:
- Use TinyDB Query for filtering
- Keep code clear and commented
- Always provide meaningful insights, not just raw numbers

User request:
{question}
"""

print("✅ Agent prompt template updated for visualizations!")

"""## Add visualization libraries

### Subtask:
Ensure necessary visualization libraries (like Matplotlib or Seaborn) are installed if they aren't already.

**Reasoning**:
Ensure necessary visualization libraries (like Matplotlib or Seaborn) are installed if they aren't already.
"""

try:
    import matplotlib.pyplot as plt
    import seaborn as sns
    print("✅ Matplotlib and Seaborn are already installed.")
except ImportError:
    print("Installing Matplotlib and Seaborn...")
    !pip install -q matplotlib seaborn
    print("✅ Matplotlib and Seaborn installed.")

"""## Modify execution environment

### Subtask:
Update the `execute_generated_code` function to include the necessary imports for visualization libraries and potentially handle the display of plots.

**Reasoning**:
Update the `execute_generated_code` function to include necessary visualization libraries in `SAFE_GLOBALS`.
"""

def _extract_execute_block(text: str) -> str:
    """
    Returns the Python code inside <execute_python>...</execute_python>.
    If no tags are found, assumes 'text' is already raw Python code.
    Also removes markdown code block delimiters if present.
    """
    if not text:
        raise RuntimeError("Empty content passed to code executor.")

    # First, try to extract the content within <execute_python> tags
    m = re.search(r"<execute_python>(.*?)</execute_python>", text, re.DOTALL | re.IGNORECASE)
    code = m.group(1).strip() if m else text.strip()

    # Then, remove markdown code block delimiters if they exist
    # This handles cases where the LLM includes markdown fences inside the execute_python block
    code = re.sub(r"```python\n?", "", code, count=1)
    code = re.sub(r"```\n?", "", code)

    # Clean up leading/trailing whitespace and empty lines
    code_lines = code.splitlines()
    cleaned_lines = [line for line in code_lines if line.strip()] # Remove empty lines
    code = "\n".join(cleaned_lines).strip() # Join back and strip leading/trailing whitespace

    return code


def execute_generated_code(
    code_or_content: str,
    *,
    db,
    orders_tbl,
    user_request: Optional[str] = None,
) -> Dict[str, Any]:
    """
    Execute code in a controlled namespace.
    Accepts either raw Python code OR full content with <execute_python> tags.
    Returns execution results: stdout, error, and extracted answer.
    """
    # Extract code
    code = _extract_execute_block(code_or_content)

    # Safe globals (only allow safe operations)
    SAFE_GLOBALS = {
        "Query": Query,
        "datetime": datetime,
        "user_request": user_request or "",
        "re": re,
        "sum": sum,
        "len": len,
        "max": max,
        "min": min,
        "sorted": sorted,
        "defaultdict": __import__('collections').defaultdict,
        "plt": __import__('matplotlib.pyplot'),
        "sns": __import__('seaborn'),
        "pd": pd # Add pandas for potential DataFrame operations in plotting
    }

    SAFE_LOCALS = {
        "db": db,
        "orders_tbl": orders_tbl,
    }

    # Capture stdout
    _stdout_buf, _old_stdout = io.StringIO(), sys.stdout
    sys.stdout = _stdout_buf
    err_text = None

    try:
        # Execute the code
        exec(code, SAFE_GLOBALS, SAFE_LOCALS)

        # Ensure plots are displayed if generated
        if 'plt' in SAFE_GLOBALS and SAFE_GLOBALS['plt'].get_fignums():
             SAFE_GLOBALS['plt'].show()

    except Exception:
        err_text = traceback.format_exc()
    finally:
        sys.stdout = _old_stdout

    printed = _stdout_buf.getvalue().strip()

    # Extract answer variables
    answer = (
        SAFE_LOCALS.get("answer_text")
        or SAFE_LOCALS.get("answer_data")
        or "No answer generated"
    )

    return {
        "code": code,
        "stdout": printed,
        "error": err_text,
        "answer": answer,
    }

print("✅ Code execution function updated with visualization libraries!")

"""## Test visualization

### Subtask:
Run the `sales_dashboard_agent` with a request that asks for a visualization to test the updated agent.

**Reasoning**:
Call the sales_dashboard_agent with a request that asks for a visualization to test the updated agent.
"""

result = sales_dashboard_agent(
    "Show me a bar chart of total revenue by region",
    db=db,
    orders_tbl=orders_tbl,
)

"""**Reasoning**:
The previous command failed because the prompt template still contained example placeholders like 'Product A' which caused a KeyError during formatting. I need to fix the prompt template by removing the example visualization pattern that was added in a previous step and rely on the agent to generate the visualization code based on the instructions.


"""

SALES_AGENT_PROMPT = """You are a senior sales data analyst. PLAN BY WRITING PYTHON CODE USING TINYDB.

Database Schema & Samples (read-only):
{schema_block}

Execution Environment (already imported/provided):
- Variables: db, orders_tbl  # TinyDB objects
- Libraries: Query (from tinydb), datetime, re, matplotlib.pyplot as plt, seaborn as sns, pandas as pd
- Natural language: user_request: str  # the original user question

PLANNING RULES (critical):
- Derive ALL filters/parameters from user_request (date ranges, regions, categories, products, customers)
- Build TinyDB queries dynamically with Query()
- For date filtering: use string comparison (dates are stored as YYYY-MM-DD strings)
- For aggregations: use Python's sum(), len(), max(), min(), statistics module
- Be conservative: this is READ-ONLY analytics (no mutations allowed)
- IF the user requests a visualization (e.g., "show in bar chart", "visualize", "plot"), GENERATE PYTHON CODE to create a plot using Matplotlib or Seaborn. Ensure the plot is displayed using `plt.show()`.

HUMAN RESPONSE REQUIREMENT (hard):
- You MUST set a variable named `answer_text` (type str) with a concise, business-friendly answer (2-3 sentences max)
- Include relevant numbers, comparisons, and insights
- If no data matches, suggest alternative queries
- Format currency as "$X,XXX.XX" and percentages as "XX.X%"

OUTPUT CONTRACT:
- Return ONLY executable Python between these tags (no extra text):
  <execute_python>
  # your python code here
  </execute_python>

CODE CHECKLIST:
1) Parse the user_request to understand what's being asked
2) Build TinyDB query with appropriate filters
3) Perform calculations (sums, averages, counts, etc.)
4) ALWAYS set `answer_text` with a human-friendly response
5) Optional: set `answer_data` (list/dict) for structured results
6) Print a brief log to stdout for debugging
7) IF a visualization is requested, include Matplotlib/Seaborn code to generate and display the plot.

EXAMPLE PATTERNS:

# Total revenue by region
Item = Query()
orders = orders_tbl.all()
west_revenue = sum(o['Revenue'] for o in orders if o['Region'] == 'West')
answer_text = f"West region generated ${{west_revenue:,.2f}} in total revenue."

# Top 5 products by profit
from collections import defaultdict
product_profit = defaultdict(float)
for order in orders_tbl.all():
    product_profit[order['Product_Name']] += order['Profit']
top_5 = sorted(product_profit.items(), key=lambda x: x[1], reverse=True)[:5]
answer_text = f"Top product: {{top_5[0][0]}} with ${{top_5[0][1]:,.2f}} profit."

# Date filtering
Item = Query()
nov_orders = orders_tbl.search((Item.Order_Date >= '2024-11-01') & (Item.Order_Date <= '2024-11-30'))
nov_revenue = sum(o['Revenue'] for o in nov_orders)
answer_text = f"November 2024 revenue: ${{nov_revenue:,.2f}} from {{len(nov_orders)}} orders."


Constraints:
- Use TinyDB Query for filtering
- Keep code clear and commented
- Always provide meaningful insights, not just raw numbers

User request:
{question}
"""

print("✅ Agent prompt template fixed by removing example visualization pattern!")

"""**Reasoning**:
Now that the prompt template is fixed, I can call the sales_dashboard_agent again with a request that asks for a visualization to test the updated agent.


"""

result = sales_dashboard_agent(
    "Show me a bar chart of total revenue by region",
    db=db,
    orders_tbl=orders_tbl,
)

"""## Refine and iterate

### Subtask:
Refine the agent's ability to generate correct visualization code based on the previous failure and successful test.

**Reasoning**:
Reviewing the previous successful visualization code, it seems the agent already has a good grasp of generating basic bar charts. The prompt doesn't need significant changes regarding the core plotting instructions, but adding more emphasis on good visualization practices like clear titles, axis labels, and potentially adjusting figure size would be beneficial. I will update the prompt with these considerations.
"""

SALES_AGENT_PROMPT = """You are a senior sales data analyst. PLAN BY WRITING PYTHON CODE USING TINYDB.

Database Schema & Samples (read-only):
{schema_block}

Execution Environment (already imported/provided):
- Variables: db, orders_tbl  # TinyDB objects
- Libraries: Query (from tinydb), datetime, re, matplotlib.pyplot as plt, seaborn as sns, pandas as pd
- Natural language: user_request: str  # the original user question

PLANNING RULES (critical):
- Derive ALL filters/parameters from user_request (date ranges, regions, categories, products, customers)
- Build TinyDB queries dynamically with Query()
- For date filtering: use string comparison (dates are stored as YYYY-MM-DD strings)
- For aggregations: use Python's sum(), len(), max(), min(), statistics module
- Be conservative: this is READ-ONLY analytics (no mutations allowed)
- IF the user requests a visualization (e.g., "show in bar chart", "visualize", "plot"), GENERATE PYTHON CODE to create a plot using Matplotlib or Seaborn. Ensure the plot is displayed using `plt.show()`.
- When generating visualizations, ensure the plot has a clear title, appropriate axis labels (including units like currency or quantity), and consider adjusting the figure size for readability if there are many items.

HUMAN RESPONSE REQUIREMENT (hard):
- You MUST set a variable named `answer_text` (type str) with a concise, business-friendly answer (2-3 sentences max)
- Include relevant numbers, comparisons, and insights
- If no data matches, suggest alternative queries
- Format currency as "$X,XXX.XX" and percentages as "XX.X%"

OUTPUT CONTRACT:
- Return ONLY executable Python between these tags (no extra text):
  <execute_python>
  # your python code here
  </execute_python>

CODE CHECKLIST:
1) Parse the user_request to understand what's being asked
2) Build TinyDB query with appropriate filters
3) Perform calculations (sums, averages, counts, etc.)
4) ALWAYS set `answer_text` with a human-friendly response
5) Optional: set `answer_data` (list/dict) for structured results
6) Print a brief log to stdout for debugging
7) IF a visualization is requested, include Matplotlib/Seaborn code to generate and display the plot, making sure the plot is well-labeled and readable.

EXAMPLE PATTERNS:

# Total revenue by region
Item = Query()
orders = orders_tbl.all()
west_revenue = sum(o['Revenue'] for o in orders if o['Region'] == 'West')
answer_text = f"West region generated ${{west_revenue:,.2f}} in total revenue."

# Top 5 products by profit
from collections import defaultdict
product_profit = defaultdict(float)
for order in orders_tbl.all():
    product_profit[order['Product_Name']] += order['Profit']
top_5 = sorted(product_profit.items(), key=lambda x: x[1], reverse=True)[:5]
answer_text = f"Top product: {{top_5[0][0]}} with ${{top_5[0][1]:,.2f}} profit."

# Date filtering
Item = Query()
nov_orders = orders_tbl.search((Item.Order_Date >= '2024-11-01') & (Item.Order_Date <= '2024-11-30'))
nov_revenue = sum(o['Revenue'] for o in nov_orders)
answer_text = f"November 2024 revenue: ${{nov_revenue:,.2f}} from {{len(nov_orders)}} orders."


Constraints:
- Use TinyDB Query for filtering
- Keep code clear and commented
- Always provide meaningful insights, not just raw numbers

User request:
{question}
"""

print("✅ Agent prompt template refined with visualization best practices!")

"""## Summary:

### Data Analysis Key Findings

*   The `SALES_AGENT_PROMPT` was successfully updated to include explicit instructions for generating visualization code using libraries like Matplotlib and Seaborn when requested by the user.
*   The environment was checked, and it was confirmed that `matplotlib` and `seaborn` were already installed.
*   The `execute_generated_code` function was modified to include `matplotlib.pyplot` and `seaborn` in the `SAFE_GLOBALS` and to attempt to display plots using `plt.show()` if figures are generated.
*   An initial test of the visualization capability failed due to problematic placeholder examples in the prompt template.
*   After fixing the prompt template by removing the incorrect examples, a subsequent test with the request "Show me a bar chart of total revenue by region" was successful, resulting in the generation and display of the requested bar chart.
*   The `SALES_AGENT_PROMPT` was further refined to include instructions for generating higher-quality visualizations with clear titles, appropriate axis labels, and consideration for figure size.

### Insights or Next Steps

*   The agent is now capable of generating basic visualizations based on user requests.
*   Further testing with various visualization types (e.g., line charts, scatter plots) and data aggregations is needed to ensure the agent's robustness in generating correct plotting code in different scenarios.

"""
